import java.util.concurrent.Semaphore;

public class SharedSemaphore {
	private int _data;
	
	private boolean _writing = false;
	private boolean _reading = true;
	
	// Thread Safe Mechanisms
	Semaphore writing = new Semaphore (1);
	Semaphore reading;
	
	// Local Setters
	private void setWriting (boolean value) { _writing = value; }
	private void setReading (boolean value) { _reading = value; }
	
	// Local Getters
	private boolean isWriting () { return _writing; }
	private boolean isReading () { return _reading; }
	
	
	// Constructor
	public SharedSemaphore (final int readerPermits)
	{
		reading = new Semaphore(readerPermits);
	}
	
	
	public int read(String id) throws InterruptedException {
		reading.acquire();
		
		int rv;
		try {
			while (isWriting()) {
				condNotWriting.await();
			}
			
			// Reading
			this.setReading(true);
			rv = _data;
			System.out.format("READER %s <<   %d\n", id, _data);
			
			// Signal
			this.setReading(false);
			condNotReading.signal();
			
		} finally {
			reading.release();
		}
		
		return rv;
	}
	
	public void write(String id, int data) throws InterruptedException {
		lock.lock();
		
		try {
			while (isReading() || isWriting()) {
				if (isReading())
					condNotReading.await();
				
				if (isWriting())
					condNotWriting.await();
			}
			
			// Writing
			setWriting(true);
			_data = data;
			System.out.format("WRITER %s   >> %d\n", id, _data);
			
			// Signal
			setWriting(false);
			condNotWriting.signal();
			
		} finally {
			lock.unlock();
		}
	}
}
